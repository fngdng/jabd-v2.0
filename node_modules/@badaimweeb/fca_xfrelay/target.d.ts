/// <reference types="node" />
import EventEmitter from 'events';
import { API } from 'xfrelay_server';
import { DTSocketClient } from '@badaimweeb/js-dtsocket';
import { Buffer as Buffer$1 } from 'buffer';
import { Readable } from 'stream';

type MessagePacket = {
    type: "message";
    content: string;
    authorID: string;
    messageID: string;
    threadID: string;
    timestamp: number;
    mentions: {
        targetID: string;
        targetType: "p" | "t" | string;
        offset: number;
        length: number;
    }[];
    replyData?: {
        authorID: string;
        messageID: string;
        timestamp: number;
    };
};
type AttachmentPacket = {
    type: "attachment";
    attachmentID: string;
    threadID: string;
    targetMessageID: string;
    url: string;
    timestamp: number;
    mimeType: string;
    name: string;
    thumbnailURL?: string;
    thumbnailMIME?: string;
    alternativeURL?: string;
};
type MessageUnsendPacket = {
    type: "message_unsend";
    messageID: string;
    threadID: string;
    eventAuthor: string;
    eventTimestamp: number;
    messageTimestamp: number;
};
type MessageEditPacket = {
    type: "message_edit";
    messageID: string;
    newContent: string;
};
type MessageReactionPacket = {
    type: "message_reaction";
    messageID: string;
    threadID: string;
    authorID: string;
    emoji: string;
};
type OldMessagePacket = {
    type: "message_old";
    content: string;
    authorID: string;
    messageID: string;
    threadID: string;
    timestamp: number;
    mentions: {
        targetID: string;
        targetType: "p" | "t" | string;
        offset: number;
        length: number;
    }[];
    replyData?: {
        authorID: string;
        messageID: string;
        timestamp: number;
    };
};
type AddParticipantPacket = {
    type: "add_participant";
    threadID: string;
    participantID: string;
};
type ClearPinnedMessagesPacket = {
    type: "clear_pinned_messages";
    threadID: string;
};
type PinMessagePacket = {
    type: "add_pin_message";
    threadID: string;
    messageID: string;
};
type UserData1Packet = {
    type: "user_data_1";
    userID: string;
    name: string;
    smallProfilePictureURL: string;
    profilePictureFallbackRedirectURL: string;
};
type UserDataFullPacket = {
    type: "user_data_full";
    userID: string;
    fullName: string;
    firstName: string;
    smallProfilePictureURL: string;
    fullProfilePictureURL: string;
};
type StickerPacket = {
    type: "sticker";
    stickerID: string;
    packID: string;
    url: string;
    mimeType: string;
    threadID: string;
    messageID: string;
};
type ThreadDataPacket = {
    type: "thread_data";
    threadID: string;
    threadAvatarURL?: string;
    threadName?: string;
    folder: string;
};
type FlagMessageMetaAIBotPacket = {
    type: "flag_message_meta_ai";
    messageID: string;
    threadID: string;
};
type ThreadNameUpdatePacket = {
    type: "thread_name_update";
    threadID: string;
    threadName: string;
};
type Packet = MessagePacket | AttachmentPacket | MessageUnsendPacket | MessageEditPacket | MessageReactionPacket | OldMessagePacket | AddParticipantPacket | ClearPinnedMessagesPacket | PinMessagePacket | UserData1Packet | UserDataFullPacket | StickerPacket | ThreadDataPacket | FlagMessageMetaAIBotPacket | ThreadNameUpdatePacket;
type Sticker = {
    id: string;
    url?: string;
    mimeType?: string;
    packID?: string;
};

declare class Attachment {
    fetched: boolean;
    private _targetMessageID?;
    /** Get target message this attachment is in. */
    get targetMessage(): Message | undefined;
    /** Set ID of target message this attachment is in. */
    set targetMessageID(data: string);
    private _filename?;
    /** Get/set filename of this attachment. */
    get filename(): string;
    set filename(data: string);
    private _url?;
    /** Get/set URL of this attachment. */
    get url(): string;
    set url(data: string);
    private _mime?;
    /** Get/set MIME type of this attachment. */
    get mime(): string;
    set mime(data: string);
    private _timestamp?;
    /** Get/set timestamp of this attachment. */
    get timestamp(): number;
    set timestamp(data: number);
    private _id?;
    /** Get/set ID of this attachment. */
    get id(): string;
    set id(data: string);
    private _backedData;
    /** Get/set data of this attachment. */
    get data(): Uint8Array | null;
    set data(data: Uint8Array | null);
    client: FCAXF;
    constructor(root: FCAXF, attachmentData: {
        id?: string;
        targetMessageID?: string;
        filename?: string;
        url?: string;
        mime?: string;
        timestamp?: number;
        data?: Uint8Array;
    });
}

declare class MessageMentions {
    client: FCAXF;
    users: Map<string, {
        offset: number;
        length: number;
        user: User;
    }>;
    threads: Map<string, {
        offset: number;
        length: number;
        thread: Thread;
    }>;
    /** If Meta AI is mentioned in the message, this will not be null. */
    aiMention?: {
        offset: number;
        length: number;
    };
    constructor(base: FCAXF, data: {
        targetID: string;
        targetType: "p" | "t" | "ai";
        offset: number;
        length: number;
    }[]);
    _resolveData(data: {
        targetID: string;
        targetType: "p" | "t" | "ai" | string;
        offset: number;
        length: number;
    }[]): void;
}

declare class Thread {
    fetched: boolean;
    participants: Map<string, User>;
    pinnedMessages: Map<string, Message>;
    id?: string;
    private _imageURL?;
    get imageURL(): string | undefined;
    set imageURL(value: string | undefined);
    private _name?;
    get name(): string | undefined;
    set name(value: string | undefined);
    client: FCAXF;
    /** Check if this thread is a group. */
    get isGroup(): boolean;
    get type(): "GROUP" | "DM" | "UNKNOWN";
    constructor(root: FCAXF, messageData: {
        id?: string;
    });
    /**
     * Send a message to this thread.
     *
     * - Note 1: You DO NOT NEED TO and SHOULD NOT create a new Message object to send rich content.
     * - Note 2: Facebook doesn't allow you to include both content and attachments in the same message anymore. You should make 2 separate calls if you want to send both.
     *
     * @returns New message that was sent.
     * */
    send(message: string | ({
        content: string;
        mentions?: MessageMentions | ({
            targetID: string;
            targetType: "user" | "thread";
            offset: number;
            length: number;
        } | {
            targetType: "ai";
            offset: number;
            length: number;
        })[];
    } | {
        attachments?: (string | Buffer | ReadableStream<string | Uint8Array> | Readable | Uint8Array | Attachment | {
            filename: string;
            data: string | Buffer | ReadableStream<string | Uint8Array> | Readable | Uint8Array;
            mime?: string | null;
        })[];
        sendAttachmentsCompressed?: false | "zstd";
    } | {
        stickerID: string;
    }) | Message, replyMessageID?: string): Promise<Message>;
    /** Fetch this thread's data */
    fetch(force?: boolean): Promise<this>;
    /** Update this thread's name */
    setName(name?: string | null): Promise<this>;
}

declare class User {
    fetched: boolean;
    id?: string;
    client: FCAXF;
    fullName?: string;
    firstName?: string;
    profilePictureURL?: string;
    smallProfilePictureURL?: string;
    get thread(): Thread;
    constructor(root: FCAXF, messageData: {
        id?: string;
    });
    /** Send a private message to this user */
    send(message: string | Message): Promise<Message>;
    /** Fetch data for this user. */
    fetch(force?: boolean): Promise<this>;
}

declare class Message {
    fetched: boolean;
    deleted: boolean;
    edited: boolean;
    private _threadID?;
    private _authorID?;
    private _id?;
    private _createdAt?;
    private _replyTargetID?;
    private _content?;
    private _attachments;
    private _mentions;
    private _reactions;
    private _sticker;
    client: FCAXF;
    /** Get target message this message is replying to. */
    get replyTarget(): Message | void;
    /** Set ID of target message this message is replying to. */
    set replyTargetID(data: string);
    /** Get this message's thread. */
    get thread(): Thread | undefined;
    /** Set thread ID of this message. */
    set threadID(data: string);
    /** Get author of this message. */
    get author(): User | undefined;
    /** Set author ID of this message. */
    set authorID(data: string);
    /** Get/set timestamp of this message. */
    get created(): number;
    set created(data: number);
    /** Get/set content of this message. */
    get content(): string;
    set content(data: string);
    /** Get/set ID of this message. */
    get id(): string;
    set id(data: string);
    /** Get mentions in this message. */
    get mentions(): MessageMentions;
    /** Get attachments in this message. */
    get attachments(): Map<string, Attachment>;
    /** Get reactions in this message. */
    get reactions(): Map<string, string>;
    /** Get/set sticker in this message. */
    get sticker(): Sticker | null;
    set sticker(data: Sticker | null);
    private _isAI;
    /** Check if this message is AI-generated (LLM) from Facebook. */
    get isAI(): boolean;
    set isAI(data: boolean);
    /** Check if this message is coming from our own account. */
    get isSelf(): boolean;
    constructor(root: FCAXF, messageData: {
        threadID?: string;
        authorID?: string;
        id?: string;
        isAI?: boolean;
        timestamp?: number;
        content?: string;
        replyTarget?: string;
        mentions?: {
            targetID: string;
            targetType: "p" | "t";
            offset: number;
            length: number;
        }[];
        attachments?: {
            filename?: string;
            url?: string;
            mime?: string;
            timestamp?: number;
        }[];
        reactions?: {
            [authorID: string]: string;
        };
        sticker?: Sticker;
    });
    /**
     * Reply to this message.
     *
     * - Note 1: You DO NOT NEED TO and SHOULD NOT create a new Message object to send rich content.
     * - Note 2: Facebook doesn't allow you to include both content and attachments in the same message anymore. You should make 2 separate calls if you want to send both.
     *
     * @returns New message that was sent.
     * */
    reply(message: Parameters<Thread["send"]>[0]): Promise<Message>;
    /** Edit this message. */
    edit(newContent: string): Promise<this>;
    /** Unsend/delete this message so that no one else can see your message, but they still know that you've sent something and then unsend. */
    unsend(): Promise<this>;
    /** Set a reaction for this message. */
    setReaction(emoji: string): Promise<this>;
    /** Fetch this message. */
    fetch(force?: boolean): Promise<this>;
}

declare class CachedManager<DataType> {
    readonly client: FCAXF;
    cache: Map<string, DataType>;
    constructor(client: FCAXF);
    resolve(idOrInstance: string | DataType): DataType | undefined;
    resolveID(idOrInstance: string | DataType): string | undefined;
}

declare class MessageCachedManager extends CachedManager<Message> {
    readonly client: FCAXF;
    constructor(client: FCAXF);
    resolveNull(idOrInstance: string | Message): Message;
}

declare class ThreadCachedManager extends CachedManager<Thread> {
    readonly client: FCAXF;
    constructor(client: FCAXF);
    /** Attempt to get thread in cache, if not found then substitute with empty class (useful for abritary linking) */
    resolveNull(idOrInstance: string | Thread): Thread;
    /** Return data from cache if exist, otherwise attempt to fetch thread data. */
    fetch(id: string): Promise<Thread>;
    /** Create a new thread with initial message. */
    create(participants: (string | User)[], message: string | ({
        content: string;
        mentions?: MessageMentions | ({
            targetID: string;
            targetType: "user" | "thread";
            offset: number;
            length: number;
        } | {
            targetType: "ai";
            offset: number;
            length: number;
        })[];
    } | {
        attachments?: (string | Buffer | ReadableStream<string | Uint8Array> | Readable | Uint8Array | Attachment | {
            filename: string;
            data: string | Buffer | ReadableStream<string | Uint8Array> | Readable | Uint8Array;
            mime?: string | null;
        })[];
        sendAttachmentsCompressed?: false | "zstd";
    } | {
        stickerID: string;
    }) | Message, threadName?: string): Promise<void>;
}

declare class UserCachedManager extends CachedManager<User> {
    readonly client: FCAXF;
    constructor(client: FCAXF);
    /** Attempt to get user in cache, if not found then substitute with empty class (useful for abritary linking) */
    resolveNull(idOrInstance: string | User): User;
    /** Return data from cache if exist, otherwise attempt to fetch user data. */
    fetch(ids: string | string[]): Promise<Map<string, User>>;
}

declare class AttachmentCachedManager extends CachedManager<Attachment> {
    readonly client: FCAXF;
    constructor(client: FCAXF);
    resolveNull(idOrInstance: string | Attachment): Attachment;
}

interface FCAXF extends EventEmitter {
    /** Fired when there is a new message. */
    on(event: "message", listener: (message: Message) => void): this;
    /** Fired when a message is deleted. */
    on(event: "message_unsend", listener: (message: Message) => void): this;
    /** Fired when a message is edited. */
    on(event: "message_edit", listener: (message: Message, oldContent: string | null) => void): this;
    /**
     * Fired when new reaction is found.
     *
     * **NOTE: THIS EVENT IS ALSO FIRED WHEN A MESSAGE JUST LOADED WITH A REACTION. CHECK BEFORE RELYING ON THIS EVENT.**
     */
    on(event: "message_reaction", listener: (message: Message, reaction: {
        emoji: string;
        author: User;
    }) => void): this;
    /** Fired when someone updates a thread name. */
    on(event: "thread_name_update", listener: (thread: Thread, oldName: string | null) => void): this;
    on(event: "new_tabs", listener: (tabIDs: string[]) => void): this;
    on(event: "remove_tabs", listener: (tabIDs: string[]) => void): this;
    on(event: "ready", listener: () => void): this;
    on(event: "no_tabs", listener: () => void): this;
    on(event: "raw_data", listener: (tabID: string, data: string) => void): this;
    on(event: "raw_packet", listener: (packets: Packet[]) => void): this;
    on(event: string | symbol, listener: (...args: any[]) => void): this;
}
declare class FCAXF extends EventEmitter {
    #private;
    /** Messages cache manager. You can fetch message from here. */
    messages: MessageCachedManager;
    /** Threads cache manager. You can fetch thread from here. */
    threads: ThreadCachedManager;
    /** Users cache manager. You can fetch user from here. */
    users: UserCachedManager;
    /** Attachment cache manager. You shouldn't use this unless you have to. */
    attachments: AttachmentCachedManager;
    /** List of available tab UUID. This is a private API, you SHOULD NOT USE THIS. */
    _availableTabs: Set<string>;
    ready: boolean;
    /** This is a private API, you SHOULD NOT USE THIS. */
    get _taskID(): number;
    /** This is a private API, you SHOULD NOT USE THIS. */
    get _requestID(): number;
    /** This is a private API, you SHOULD NOT USE THIS. */
    get relayAPI(): DTSocketClient<API>;
    /** This is a private API, you SHOULD NOT USE THIS. */
    _specificDataTable: Map<string, {
        currentUserID: string;
        serverID: string;
        lsVersion: string;
    }>;
    get currentUserID(): string[];
    private _resolveInjectable;
    /** For initial tab waiting. */
    _injectablePromise: Promise<void>;
    /** This is a private API, you SHOULD NOT USE THIS. */
    _encryptString(str: string): Promise<string>;
    /** This is a private API, you SHOULD NOT USE THIS. */
    _decryptString(str: string): Promise<string>;
    /** This is a private API, you SHOULD NOT USE THIS. */
    _encryptBuffer(buf: Buffer$1): Promise<string>;
    constructor(relayAPI: DTSocketClient<API>, encryptionKey: CryptoKey);
    /**
     * Prepare attachment to be sent (upload to Facebook first before including it in message). Useful if you want to synchronize sending 2 messages, one with attachment and one with content.
     */
    prepareAttachment(filename: string, attachment: Buffer$1 | Uint8Array | string | ReadableStream<string | Uint8Array> | Readable, mime?: string | null, sendCompressed?: false | "zstd"): Promise<Attachment>;
    /** This is a private API, you SHOULD NOT USE THIS. */
    _sendData(tabID: string, data: string): Promise<void>;
}

declare function loginToRelay({ relayAddress, accountID, encryptionKey, waitForTab }: {
    relayAddress: `${string}!${string}`;
    accountID: string;
    encryptionKey: string;
    waitForTab?: boolean;
}): Promise<FCAXF>;

export { Attachment, Message, Thread, User, loginToRelay as default };
