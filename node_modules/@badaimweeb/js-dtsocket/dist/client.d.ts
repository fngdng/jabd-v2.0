/// <reference types="node" />
import type { DTSocketServer } from "./server.js";
import type { ServerContext, GetTypeContext, SymbolEventTableType, SymbolProceduresType, Socket } from "./types.js";
import type { Procedure, StreamingProcedure } from "./procedures.js";
import { EventEmitter } from "events";
type ExtractContext<T extends DTSocketServer> = T extends DTSocketServer<infer C> ? C : never;
type AsyncIterableUnwrap<T> = T extends AsyncIterable<infer U> ? U : never;
type StandandProcedureArray<T extends object> = {
    [K in keyof T]: T[K] extends Procedure<any, any, any> ? K : never;
}[keyof T];
type StreamingProcedureArray<T extends object> = {
    [K in keyof T]: T[K] extends StreamingProcedure<any, any, any> ? K : never;
}[keyof T];
type StandardProcedureObject<T extends object> = {
    [K in StandandProcedureArray<T>]: T[K] extends Procedure<infer I, infer O, any> ? (input: I) => Promise<Awaited<O>> : never;
};
type StreamingProcedureObject<T extends object> = {
    [K in StreamingProcedureArray<T>]: T[K] extends StreamingProcedure<infer I, infer O, any> ? (input: I) => AsyncGenerator<O, void, unknown> : never;
};
export interface DTSocketClient<T extends DTSocketServer, SocketImpl extends Socket = Socket, Context extends ServerContext = ExtractContext<T>> extends EventEmitter {
    on<K extends keyof GetTypeContext<Context, SymbolEventTableType>["scEvents"]>(event: K, callback: (...args: Parameters<GetTypeContext<Context, SymbolEventTableType>["scEvents"][K]>) => void): this;
    on(event: string | symbol, callback: (...args: any[]) => void): this;
    emit<K extends keyof GetTypeContext<Context, SymbolEventTableType>["csEvents"]>(event: K, ...args: Parameters<GetTypeContext<Context, SymbolEventTableType>["csEvents"][K]>): boolean;
    emit(event: string | symbol, ...args: any[]): boolean;
}
export declare class DTSocketClient<T extends DTSocketServer, SocketImpl extends Socket = Socket, Context extends ServerContext = ExtractContext<T>> extends EventEmitter {
    private socket;
    nonceCounter: number;
    private m0CallbackTable;
    private m1CallbackTable;
    private m2Table;
    private m2RecvCounter;
    private m2SendCounter;
    procedure: (<APIKey extends StandandProcedureArray<GetTypeContext<Context, SymbolProceduresType>>>(x: APIKey) => (input: Parameters<GetTypeContext<Context, SymbolProceduresType>[APIKey]["execute"]>[2]) => Promise<Awaited<ReturnType<GetTypeContext<Context, SymbolProceduresType>[APIKey]["execute"]>>>);
    p: StandardProcedureObject<GetTypeContext<Context, SymbolProceduresType>>;
    streamingProcedure: (<APIKey extends StreamingProcedureArray<GetTypeContext<Context, SymbolProceduresType>>>(x: APIKey) => (input: Parameters<GetTypeContext<Context, SymbolProceduresType>[APIKey]["execute"]>[2]) => AsyncGenerator<AsyncIterableUnwrap<ReturnType<GetTypeContext<Context, SymbolProceduresType>[APIKey]["execute"]>>, void, unknown>);
    sp: StreamingProcedureObject<GetTypeContext<Context, SymbolProceduresType>>;
    _handleData(originalEmit: (event: string, ...data: any[]) => boolean, qos: number, data: Uint8Array): Promise<void>;
    constructor(socket: SocketImpl);
}
export {};
