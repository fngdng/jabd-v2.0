import { encode, decode } from "msgpack-lite";
import { EventEmitter } from "events";
;
export class DTSocketClient extends EventEmitter {
    socket;
    nonceCounter = 0;
    m0CallbackTable = new Map();
    m1CallbackTable = new Map();
    m2Table = {};
    m2RecvCounter = new Map();
    m2SendCounter = new Map();
    procedure = (x) => {
        return (input) => {
            return new Promise((resolve, reject) => {
                let nonce = this.nonceCounter++;
                this.m0CallbackTable.set(nonce, [resolve, reject]);
                this.socket.send(1, encode(input === undefined ? [
                    0, nonce, x
                ] : [
                    0, nonce, x, input
                ]));
            });
        };
    };
    p = new Proxy({}, {
        get: (_, p) => {
            return this.procedure(p);
        }
    });
    streamingProcedure = (x) => {
        return (input) => {
            let that = this;
            return (async function* () {
                let nonce = that.nonceCounter++;
                let packetNo = 0;
                let endPacketNo = -1;
                let packetList = new Map();
                let eventChannel = new EventEmitter();
                let pendingEnd = false;
                let pendingThrow = false;
                let pendingThrowReason;
                that.m1CallbackTable.set(nonce, [
                    async (remotePacketNo, value) => {
                        packetList.set(packetNo, value);
                        if (packetNo === remotePacketNo) {
                            for (;;) {
                                if (!packetList.has(packetNo))
                                    break;
                                let packet = packetList.get(packetNo);
                                let rec = eventChannel.emit("data", packet);
                                if (rec) {
                                    packetList.delete(packetNo);
                                    packetNo++;
                                }
                                else {
                                    await new Promise((resolve) => {
                                        eventChannel.once("ready", () => {
                                            resolve();
                                        });
                                        setTimeout(resolve, 50);
                                    });
                                }
                            }
                            if (endPacketNo >= packetNo) {
                                if (pendingEnd)
                                    eventChannel.emit("end");
                                if (pendingThrow)
                                    eventChannel.emit("fault", pendingThrowReason);
                            }
                        }
                    },
                    (totalPacket) => {
                        if (totalPacket === packetNo) {
                            let first = eventChannel.emit("end");
                            if (!first) {
                                eventChannel.once("ready", () => {
                                    eventChannel.emit("end");
                                });
                            }
                        }
                        else {
                            endPacketNo = totalPacket;
                            pendingEnd = true;
                        }
                    },
                    (totalPacket, reason) => {
                        if (totalPacket === packetNo) {
                            let first = eventChannel.emit("fault", reason);
                            if (!first) {
                                eventChannel.once("ready", () => {
                                    eventChannel.emit("fault", reason);
                                });
                            }
                        }
                        else {
                            endPacketNo = totalPacket;
                            pendingThrow = true;
                            pendingThrowReason = reason;
                        }
                    }
                ]);
                that.socket.send(1, encode(input === undefined ? [
                    1, nonce, x
                ] : [
                    1, nonce, x, input
                ]));
                for (;;) {
                    try {
                        yield await new Promise((resolve, reject) => {
                            eventChannel.once("data", (value) => {
                                resolve(value);
                            });
                            eventChannel.once("end", () => {
                                reject(["end"]);
                            });
                            eventChannel.once("fault", (reason) => {
                                reject(["fault", reason]);
                            });
                            eventChannel.emit("ready");
                        });
                    }
                    catch (e) {
                        if (Array.isArray(e)) {
                            if (e[0] === "end") {
                                break;
                            }
                            else if (e[0] === "fault") {
                                throw e[1];
                            }
                        }
                    }
                }
            })();
        };
    };
    sp = new Proxy({}, {
        get: (_, p) => {
            return this.streamingProcedure(p);
        }
    });
    async _handleData(originalEmit, qos, data) {
        try {
            let decodedData = decode(data);
            if (typeof decodedData[0] !== "number")
                throw new Error("Invalid data");
            switch (decodedData[0]) {
                case 0:
                    if (!qos)
                        return;
                    let m0Data = decodedData.slice(1);
                    if (typeof m0Data[0] !== "number" || typeof m0Data[1] !== "boolean")
                        throw new Error("Invalid data");
                    let callback = this.m0CallbackTable.get(m0Data[0]);
                    if (!callback)
                        return;
                    this.m0CallbackTable.delete(m0Data[0]);
                    if (m0Data[1]) {
                        callback[0](m0Data[2]);
                    }
                    else {
                        callback[1](m0Data[2]);
                    }
                    break;
                case 1:
                    if (!qos)
                        return;
                    let m1Data = decodedData.slice(1);
                    if (typeof m1Data[0] !== "number" || typeof m1Data[1] !== "number" || typeof m1Data[2] !== "number")
                        throw new Error("Invalid data");
                    let callback2 = this.m1CallbackTable.get(m1Data[0]);
                    if (!callback2)
                        return;
                    switch (m1Data[1]) {
                        case 0:
                            // Data
                            callback2[0](m1Data[2], m1Data[3]);
                            break;
                        case 1:
                            // End
                            callback2[1](m1Data[2]);
                            this.m1CallbackTable.delete(m1Data[0]);
                            break;
                        case 2:
                            // Fault
                            callback2[2](m1Data[2], m1Data[3]);
                            this.m1CallbackTable.delete(m1Data[0]);
                            break;
                    }
                    break;
                case 2:
                    // Ordered event transmission
                    if (!qos)
                        return;
                    let m2Data = decodedData.slice(1);
                    if (!this.m2RecvCounter.has(m2Data[0]))
                        this.m2RecvCounter.set(m2Data[0], 0);
                    if (typeof m2Data[1] !== "number")
                        throw new Error("Invalid data");
                    if (!this.m2Table[m2Data[0]])
                        this.m2Table[m2Data[0]] = new Map();
                    this.m2Table[m2Data[0]].set(m2Data[1], m2Data.slice(2));
                    if (m2Data[1] === this.m2RecvCounter.get(m2Data[0])) {
                        for (;;) {
                            let data = this.m2Table[m2Data[0]].get(this.m2RecvCounter.get(m2Data[0]));
                            if (!data)
                                break;
                            this.m2Table[m2Data[0]].delete(this.m2RecvCounter.get(m2Data[0]));
                            this.m2RecvCounter.set(m2Data[0], this.m2RecvCounter.get(m2Data[0]) + 1);
                            originalEmit(m2Data[0], ...data);
                        }
                    }
                    break;
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    constructor(socket) {
        super();
        this.socket = socket;
        let originalEmit = this.emit.bind(this);
        this.emit = (event, ...args) => {
            if (!this.m2SendCounter.has(event))
                this.m2SendCounter.set(event, 0);
            socket.send(1, encode([
                2, event, this.m2SendCounter.get(event), ...args
            ]));
            this.m2SendCounter.set(event, this.m2SendCounter.get(event) + 1);
            return true;
        };
        let u = this._handleData.bind(this, originalEmit);
        this.socket.on("data", u);
        function handleResumeSocket(client) {
            client.socket.once("resumeFailed", newSocket => {
                // throw all pending promises
                for (let [_, callback] of client.m0CallbackTable) {
                    callback[1]("Old connection closed");
                }
                for (let [_, callback] of client.m1CallbackTable) {
                    callback[2](0, "Old connection closed");
                }
                client.m0CallbackTable.clear();
                client.m1CallbackTable.clear();
                client.socket.removeListener("data", u);
                client.socket = newSocket;
                client.socket.on("data", u);
                handleResumeSocket(client);
            });
        }
        handleResumeSocket(this);
    }
}
