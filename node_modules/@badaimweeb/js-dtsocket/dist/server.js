import { DTSocketServer_CSocket } from "./server_csocket.js";
import { EventEmitter } from "events";
import { Buffer } from "buffer";
import { DTSocketServer_BroadcastOperator } from "./server_broadcast.js";
export class DTSocketServer extends EventEmitter {
    procedures;
    globalState;
    localState = new Map();
    rooms = new Map();
    cSockets = new Map();
    constructor(procedures, defaultGlobalState) {
        super();
        this.procedures = procedures;
        this.originalEmit = this.emit.bind(this);
        this.emit = (event, ...args) => {
            // Broadcast to all sockets
            for (const cSocket of this.cSockets.values()) {
                cSocket.emit(event, ...args);
            }
            return true;
        };
        this.globalState = defaultGlobalState || {};
    }
    async processSession(socket) {
        const socketID = Buffer.from(new Uint8Array(await crypto.subtle.digest("SHA-512", Buffer.from(socket.connectionPK)))).toString("hex");
        const cSocket = new DTSocketServer_CSocket(socketID, socket, this);
        this.originalEmit("session", cSocket);
        this.cSockets.set(socketID, cSocket);
        return cSocket;
    }
    async removeSession(socket) {
        const socketID = Buffer.from(new Uint8Array(await crypto.subtle.digest("SHA-512", Buffer.from(socket.connectionPK)))).toString("hex");
        this.cSockets.delete(socketID);
        for (let rooms of this.rooms.values()) {
            rooms.delete(socketID);
        }
    }
    to(room) {
        return new DTSocketServer_BroadcastOperator(this, [].concat(room));
    }
}
