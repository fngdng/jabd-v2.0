import { TypedEmitter } from "tiny-typed-emitter";
import { WrappedConnection } from "./connection";
interface ProtoV2dSessionEvent {
    /** Use this to receive data */
    'data': (QoS: 0 | 1, data: Uint8Array) => void;
    /** For internal purposes only: Also captures raw packet that will send to other side */
    'data_ret': (data: Uint8Array) => void;
    /** Close */
    'closed': () => void;
    'disconnected': () => void;
    'connected': () => void;
    'resumeFailed': (newStream: ProtoV2dSession) => void;
    'wcChanged': (oldWC: WrappedConnection | null, newWC: WrappedConnection | null) => void;
    /** Ping */
    'ping': (ping: number) => void;
    /** Final close. This will be emitted by client reconnection handler. No reconnection will be made. */
    'finalClose': () => void;
}
/**
 * The session object represents a ProtoV2d connection between client and server. It is the main way to receive and send data.
 *
 * Contains logic used after handshake.
 */
export default class ProtoV2dSession<BackendData = any> extends TypedEmitter<ProtoV2dSessionEvent> {
    connectionPK: string;
    protocolVersion: number;
    clientSide: boolean;
    timeout: number;
    pingInterval: number;
    avgPingCount: number;
    closed: boolean;
    get connected(): boolean;
    private _qos1Buffer;
    private _qos1Wait;
    private _qos1ACKCallback;
    private _qos1Counter;
    private _pingClock;
    private _wc;
    get wc(): WrappedConnection<BackendData> | null;
    set wc(wc: WrappedConnection<BackendData> | null);
    private _ping;
    private _pings;
    get ping(): number;
    get avgPing(): number;
    private _encryption;
    set encryption(key: CryptoKey[]);
    constructor(connectionPK: string, protocolVersion: number, clientSide: boolean, wc: WrappedConnection<BackendData>, encryption: CryptoKey[], timeout?: number, pingInterval?: number, avgPingCount?: number);
    private _decrypt;
    private _encrypt;
    private _generatePing;
    private _waitPromise;
    private _handleWC;
    private _handleOldWC;
    private _handleOldWC2;
    private _handleIncomingWCMessage;
    private _bindHandleIncomingWCMessage;
    private _handleWCCloseEvent;
    private _bindHandleWCCloseEvent;
    /** Destroy object without destroying WC. All listener will be removed to make this object GC-able. WC pointer will also be null. */
    destroy(): void;
    /** Close connection and destory object. All listener will be removed to make this object GC-able. WC pointer will also be null. */
    close(reason?: string): void;
    /** Send data to other side */
    send(QoS: 0 | 1, data: Uint8Array, overrideDupID?: number): Promise<void>;
}
export {};
